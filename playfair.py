# -*- coding: utf-8 -*-
"""PLAYFAIR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BPxmUn0wOqRcHdiSAGXz0d4sf5nmLDwc
"""

from string import ascii_uppercase
from itertools import product
from re import findall

def part(seq,n):
  return [seq[i:i+n] for i in range(0,len(seq),n)]

def uniq(seq):
    seen = {}
    return [seen.setdefault(x, x) for x in seq if x not in seen]

def playfair(key):
  
  def canonicalize(s):
        return "".join(filter(str.isupper, s.upper())).replace('J', 'I')
 
    # Build 5x5 matrix.
  m = part(uniq(canonicalize(key + ascii_uppercase)), 5)
  enc = {}
 
    # Map pairs in same row.
  for row in m:
    for i, j in product(range(5), repeat=2):
      if i != j:
        enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]             
    # Map pairs in same column.
    for c in zip(*m):
        for i, j in product(range(5), repeat=2):
            if i != j:
                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]
 
    # Map pairs with cross-connections.
    for i1, j1, i2, j2 in product(range(5), repeat=4):
        if i1 != i2 and j1 != j2:
            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]
 
    # Generate reverse translations.
    dec = dict((v, k) for k, v in enc.items())
 
    def sub_enc(txt):
        lst = findall(r"(.)(?:(?!\1)(.))?", canonicalize(txt))
        return " ".join(enc[a + (b if b else 'X')] for a, b in lst)
 
    def sub_dec(encoded):
        return " ".join(dec[p] for p in part(canonicalize(encoded), 2))
 
    return sub_enc, sub_dec
 
 
(encode, decode) = playfair("KEY")
orig = "MESSAGE"
print("Original:", orig)
enc = encode(orig)
print ("Encoded:", enc)
print ("Decoded:", decode(enc))

## attack cipher only

from collections import OrderedDict 
def play_fair(plain,key):
  alphabet = "ABCDEFGHJKLMNOPQRSTUVWXYZ"
  for i in range(len(key)):
    if(key[i] == 'I'):
      key[i] = 'J'
    alphabet = alphabet.replace(key[i],'')
  key = "".join(OrderedDict.fromkeys(key))
  alphabet = key + alphabet
  #print("KEY: ",alphabet)
  
  res = ""
  i=0
  while(i<len(plain)):
    #print(i)
    a = plain[i]
    i = i+1
    b=""
    if(i<len(plain)):
      if(a == plain[i]):
        b = 'X'
    if (i == len(plain)):
        b = 'X'
    elif(b!='X'):
      b = plain[i]
      i = i+1
    #print(a,b)
    n1 = alphabet.find(a)
    n2 = alphabet.find(b)
    r1 = n1//5
    c1 = n1%5
    r2 = n2//5
    c2 = n2%5
    #print(n1,n2,r1,c1,r2,c2)
     ##same column
      
    if(c1==c2):
      res += alphabet[((r1+1)%5)*5+c1]
      res += alphabet[((r2+1)%5)*5+c2]
      
      ## same row
    elif(r1 == r2):
      res += alphabet[(r1*5)+(c1+1)%5]
      res += alphabet[(r2*5)+(c2+1)%5]
      
      ## with cross-connections
    else:
      res += alphabet[(r1*5)+c2]
      res += alphabet[(r2*5)+c1]
    #print(res)
  return res

plain = "MESSAGE"
key = "KEY"
print("PLAIN: ",plain)
print("CIPHER: ",play_fair(plain,key))
print("PLAIN: ",play_fair(play_fair(plain,key),key))





